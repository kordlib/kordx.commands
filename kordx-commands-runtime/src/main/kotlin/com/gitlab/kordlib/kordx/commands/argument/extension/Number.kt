package com.gitlab.kordlib.kordx.commands.argument.extension

import com.gitlab.kordlib.kordx.commands.argument.Argument
import com.gitlab.kordlib.kordx.commands.argument.result.ArgumentResult
import com.gitlab.kordlib.kordx.commands.argument.result.extension.FilterResult
import com.gitlab.kordlib.kordx.commands.argument.result.extension.filter
import kotlin.random.Random

/**
 * Returns a new Argument that limits the acceptable range of values to the [range].
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
fun <T, CONTEXT> Argument<T, CONTEXT>.inRange(
        range: ClosedRange<T>
): Argument<T, CONTEXT> where T : Number, T : Comparable<T> = object : Argument<T, CONTEXT> by this {

    @Suppress("IMPLICIT_CAST_TO_ANY")
    override val example: String
        get() = when (range.start) {
            is Float, is Double -> Random.nextDouble(range.start.toDouble(), range.endInclusive.toDouble())
            else -> Random.nextLong(range.start.toLong(), range.endInclusive.toLong())
        }.toString()

    override suspend fun parse(words: List<String>, fromIndex: Int, context: CONTEXT): ArgumentResult<T> {
        return this@inRange.parse(words, fromIndex, context).filter {
            if (it in range) FilterResult.Pass
            else FilterResult.Fail("expected number in range of [${range.start}..${range.endInclusive}]")
        }
    }

}

/**
 * Returns a new Argument that limits the acceptable range of values to positive numbers (including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("longPositive")
fun <CONTEXT> Argument<Long, CONTEXT>.positive(): Argument<Long, CONTEXT> = inRange(0L..Long.MAX_VALUE)

/**
 * Returns a new Argument that limits the acceptable range of values to positive numbers (not including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("longStrictPositive")
fun <CONTEXT> Argument<Long, CONTEXT>.strictPositive(): Argument<Long, CONTEXT> = inRange(1L..Long.MAX_VALUE)

/**
 * Returns a new Argument that limits the acceptable range of values to negative numbers (including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("longNegative")
fun <CONTEXT> Argument<Long, CONTEXT>.negative(): Argument<Long, CONTEXT> = filterWithExample({ Random.nextLong(Long.MIN_VALUE, 0).toString() }) {
    if (it <= 0) FilterResult.Pass
    else FilterResult.Fail("expected number in range of [${Long.MIN_VALUE}..0]")
}

/**
 * Returns a new Argument that limits the acceptable range of values to negative numbers (not including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("longStrictNegative")
fun <CONTEXT> Argument<Long, CONTEXT>.strictNegative(): Argument<Long, CONTEXT> = filterWithExample({ Random.nextLong(Long.MIN_VALUE, -1).toString() }) {
    if (it <= -1) FilterResult.Pass
    else FilterResult.Fail("expected number in range of [${Long.MIN_VALUE}..-1]")
}

/**
 * Returns a new Argument that limits the acceptable range of values to positive numbers (including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("intPositive")
fun <CONTEXT> Argument<Int, CONTEXT>.positive(): Argument<Int, CONTEXT> = inRange(0..Int.MAX_VALUE)

/**
 * Returns a new Argument that limits the acceptable range of values to positive numbers (not including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("intStrictPositive")
fun <CONTEXT> Argument<Int, CONTEXT>.strictPositive(): Argument<Int, CONTEXT> = inRange(1..Int.MAX_VALUE)

/**
 * Returns a new Argument that limits the acceptable range of values to negative numbers (including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("intNegative")
fun <CONTEXT> Argument<Int, CONTEXT>.negative(): Argument<Int, CONTEXT> = filterWithExample({ Random.nextInt(Int.MIN_VALUE, 0).toString() }) {
    if (it <= 0) FilterResult.Pass
    else FilterResult.Fail("expected number in range of [${Int.MIN_VALUE}..0]")
}

/**
 * Returns a new Argument that limits the acceptable range of values to negative numbers (not including 0).
 *
 * > Examples generated by this argument will only consider the current range. More complex Arguments
 * might thus return invalid example values.
 */
@JvmName("LongStrictNegative")
fun <CONTEXT> Argument<Int, CONTEXT>.strictNegative(): Argument<Int, CONTEXT> = filterWithExample({ Random.nextInt(Int.MIN_VALUE, -1).toString() }) {
    if (it <= -1) FilterResult.Pass
    else FilterResult.Fail("expected number in range of [${Int.MIN_VALUE}..-1]")
}

private inline fun <T, CONTEXT> Argument<T, CONTEXT>.filterWithExample(
        crossinline example: () -> String,
        crossinline filter: (T) -> FilterResult
) = object : Argument<T, CONTEXT> by this {
    override val example: String
        get() = example()

    override suspend fun parse(words: List<String>, fromIndex: Int, context: CONTEXT): ArgumentResult<T> {
        return this@filterWithExample.parse(words, fromIndex, context).filter(filter)
    }
}
