package dev.kordx.commands.model.command

import dev.kordx.commands.argument.Argument
import dev.kordx.commands.model.metadata.Metadata
import dev.kordx.commands.model.module.Module
import dev.kordx.commands.model.precondition.Precondition
import dev.kordx.commands.model.processor.CommandProcessor
import dev.kordx.commands.model.processor.ProcessorContext
import org.koin.core.Koin
import org.koin.core.component.KoinComponent

/**
 * @param name The word that invokes the command.
 * Unique per [processor][dev.kordx.commands.model.processor.CommandProcessor].
 *
 * @param moduleName The name of the module that contains this command.
 *
 * @param context The context linked to this command,
 * invocations of this command with contexts that don't match will be ignored.
 *
 * @param metadata Extra data linked to this command.
 *
 * @param arguments The arguments required for this command,
 * the values generated by these are expected in the [invoke] function.
 *
 * @param modules All modules currently know by the [CommandProcessor], with their [name][Module.name] as key.
 * Used in combination with [moduleName] to find the [Command.module].
 *
 * @param preconditions The preconditions the command expects to have been passed before being invoked.
 *
 * @param koin Koin instance used for dependency injection.
 *
 * @param aliasInfo Information about the alias status of the command.
 *
 * @param execution The behavior executed on [invoke].
 */
data class CommandData<T: CommandEvent>(
    val name: String,
    val moduleName: String,
    val context: ProcessorContext<*, *, T>,
    val metadata: Metadata,
    val arguments: List<Argument<*, *>>,
    val modules: MutableMap<String, Module>,
    val preconditions: List<Precondition<T>>,
    val koin: Koin,
    val aliasInfo: AliasInfo<T>,
    val execution: suspend (T, List<*>) -> Unit
)

/**
 * A Command that can be [invoked][invoke] with a [context][T] and [arguments].
 *
 * @param data The configuration of the command.
 */
class Command<T : CommandEvent>(val data: CommandData<T>) : KoinComponent {
    override fun getKoin(): Koin = data.koin

    /**
     * The preconditions the command expects to have been passed before being invoked.
     */
    val preconditions: List<Precondition<T>> get() = data.preconditions

    /**
     * context The context linked to this command,
     * invocations of this command with contexts that don't match will be ignored.
     */
    val context: ProcessorContext<*, *, T> get() = data.context

    /**
     * The word that invokes the command. Unique per [processor][CommandProcessor].
     */
    val name: String get() = data.name

    /**
     * All modules currently know by the [CommandProcessor], with their [name][Module.name] as key.
     */
    val modules: Map<String, Module> get() = data.modules

    /**
     * The arguments required for this command, the values generated by these are expected in the [invoke] function.
     */
    val arguments: List<dev.kordx.commands.argument.Argument<*, *>> get() = data.arguments

    /**
     * Returns the module of this command, found by looking up the [moduleName] in [modules].
     *
     * Throws an [IllegalStateException] when missing.
     */
    val module: Module get() = modules[data.moduleName] ?: error("expected module")

    /**
     * Information about the alias status of the command.
     */
    val aliasInfo: AliasInfo<T> get() = data.aliasInfo

    /**
     * Invokes the command with a [context] and [arguments], suspending until its execution ends.
     *
     * Calling this function with [arguments] not generated by the command's [Command.arguments] is undefined behavior.
     */
    suspend operator fun invoke(context: T, arguments: List<*>) = data.execution(context, arguments)
}
