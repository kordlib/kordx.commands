package dev.kordx.commands.kord.model

import dev.kord.common.annotation.KordExperimental
import dev.kord.common.annotation.KordUnsafe
import dev.kord.core.behavior.channel.createEmbed
import dev.kord.core.behavior.channel.createMessage
import dev.kord.core.entity.Message
import dev.kord.core.event.message.MessageCreateEvent
import dev.kord.rest.builder.message.EmbedBuilder
import dev.kord.rest.builder.message.create.MessageCreateBuilder
import dev.kordx.commands.argument.result.ArgumentResult
import kotlinx.coroutines.flow.*

/**
 * Base event functionality from an [event], providing some ease of use members.
 */
interface KordEvent {

    /**
     * The event that was parsed.
     */
    val event: MessageCreateEvent

    /**
     * The kord instance that spawned the [event].
     */
    val kord get() = event.kord

    /**
     * The message from the [event].
     */
    val message get() = event.message

    /**
     * The author of the [message] if present.
     */
    val author get() = message.author!!

    /**
     * The channel the [message] was created in.
     */
    val channel get() = message.channel

    /**
     * The guild the [message] was created in, or null if it was made in a DM.
     */
    @OptIn(KordUnsafe::class, KordExperimental::class)
    val guild get() = event.guildId?.let { kord.unsafe.guild(it) }

    /**
     * Creates a message in the [KordEvent.channel].
     *
     * @param message The [MessageCreateBuilder.content] of the message.
     */
    suspend fun respond(message: String): Message {
        return this.message.channel.createMessage(message)
    }

    /**
     *  Suspends until the user invoking this command enters a message in
     *  the [KordEvent.channel] that is accepted by the given [argument].
     *
     *  ```kotlin
     * command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member.ban()
     *     }
     * }
     * ```
     * > This function doesn't return until a valid value is entered, which might negatively impact user experience.
     * > If this is a concern, consider using the method overload that accepts an escape filter.
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T> read(
        argument: dev.kordx.commands.argument.Argument<T, MessageCreateEvent>,
        filter: suspend (T) -> Boolean = { true }
    ): T = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .map { argument.parse(it.message.content, 0, it) }
            .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
            .filterIsInstance<ArgumentResult.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .single()

    /**
     *  Suspends until the user invoking this command enters a message in
     *  the [KordEvent.channel] that is accepted by the given [argument].
     *
     *  ```kotlin
     *  command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member?.ban()
     *     }
     * }
     * ```
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @param escape a filter that stops this function from taking input when returning true,
     *  making this function return `null`.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T : Any> read(
        argument: dev.kordx.commands.argument.Argument<T, MessageCreateEvent>,
        escape: suspend (MessageCreateEvent) -> Boolean,
        filter: suspend (T) -> Boolean = { true }
    ): T? = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .takeWhile { !escape(it) }
            .map { argument.parse(it.message.content, 0, it) }
            .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
            .filterIsInstance<ArgumentResult.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .singleOrNull()

    companion object {

        /**
         * Creates a [KordEvent] from the [event].
         */
        operator fun invoke(event: MessageCreateEvent) = object : KordEvent {
            override val event: MessageCreateEvent = event
        }
    }

}

/**
 * Creates a message in the [KordEvent.channel] configured by the [builder].
 */
suspend inline fun KordEvent.respond(noinline builder: MessageCreateBuilder.() -> Unit): Message {
    return message.channel.createMessage(builder)
}

/**
 * Creates an embed in the [KordEvent.channel] configured by the [builder].
 */
suspend inline fun KordEvent.respondEmbed(builder: EmbedBuilder.() -> Unit): Message {
    return message.channel.createEmbed(builder)
}
